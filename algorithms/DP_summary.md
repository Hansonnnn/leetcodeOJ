#### 1. 最长公共子串(注意和最长公共子序列区别)

两个字符串str1和str2,长度分别为（l1,l2)。

`dp[i][j]`表示以两个字符串分别以第i和第j个字符结尾所能达到的公共子序列的长度，由于下面涉及到i-1和j-1，那么这个时候我们一般从`i=1`和`j=1`开始到`i<=len1`, `j<=len2`。

```
   if(str[i-1]=str[j-1])
        dp[i][j]=dp[i-1][j-1]+1;
   if(str[i-1]!=str[j-1])
        dp[i][j]=0;
```
就有
```
i = 0或j= 0;
dp = dp[i][j] = dp[i-1][j-1] + 1; 
i > 0且j> 0且ch1[i-1]= ch2[j-1];
dp[i][j]= 0;                        
i > 0且j> 0且ch1[i-1]!= ch2[j-1];

```
注意:
```
dp[i][0]=0(0<=i<=max(l1,l2);
dp[0][i]=0(0<=i<=max(l1,l2);
```
最长公共字串要求在原来字符中满足是连续的，最长公共子序列则不要求。

#### 2.最长公共子序列：
 
根据最长公共子序列问题的性质，我们可以规定`dp[i][j]`为字符串1的前i个字符和字符串2的前j个字符的最长公共子序列的长度,  由于下面涉及到`i-1`和`j-1`，那么这个时候我们一般从`i=1`和`j=1`开始到`i<=len1`, `j<=len2`。
             
* ch1[i-1] = ch2[j-1] ,那么dp[i][j]= dp[i-1][j-1] + 1;

* ch1[i-1]!=ch2[j-1],那么我们知道ch1[i]和ch2[j]不可能在同一个公共子序列里出现，那么这个时候的最长的子序列可能以ch1[i]或ch2[j]结尾，那么由于dp[i][j]= max{dp[i-1][j], dp[i][j-1]};
这个时候所有i=0或j=0的dp[i][j]= 0；就有
```
i = 0或j= 0;
dp= dp[i][j] = dp[i-1][j-1] + 1;
i > 0且j> 0且ch1[i-1]= ch2[j-1];
dp[i][j]= max {dp[i-1][j],dp[i][j-1]};
i > 0且j> 0且ch1[i-1]!= ch2[j-1];
```
#### 3.最长上升或下降子序列

给定一个序列`a1,a2..........an`;
`dp[i]`表示以`ai`结尾的最长上升子序列长度(下降相反）

核心代码

```C++
for（i=1；i<=n;i++){
   dp[i]=1;
   for（k=1;k<i;k++){
        if(ak<ai&&dp[i]<dp[k]+1)
          dp[i]=dp[k]+1;
   }
}
```

#### 4.最大子序列的和问题

给定一个序列```a1,a2..........an```;
求子序列的和最大问题`dp[i]`表示以`ai`结尾的子序列和,`max`为最大子序列和。

核心代码:
```
1.如果输入的数据全部为负数则最大值就是序列中的一个最大值
2.如果有正数
for（i=1;i<=n;i++){
   dp[i]=dp[i-1]+ai;
   if(dp[i]<0)
      dp[i]=0;
   if(max<dp[i])
      max=dp[i];
}
```

#### 5.数塔问题
给定一个数组`s[n][m]`构成一个数塔求从最上面走到最低端经过的路径和最大，我们采用自底向上的思路求解问题（注意从倒数第二行开始），
`dp[i][j]`表示走到第i行第j个的最大值，那么就有`dp[i][j]=max{dp[i-1][j-1],dp[i-1][j]}+s[i][j]`;

核心代码：

```
for(i=n-1;i>=1;i--){
    for(j=1;j<=i;j++){
        dp[i][j]=max{dp[i-1][j-1],dp[i-1][j]}+s[i][j]
    }
}
```
最后`dp[1][1]`即为最大值

#### 6.01背包问题

有N件物品和一个容量为V的背包。第i件物品的体积是`v[i]`，价值是`c[i]`。求解将哪些物品装入背包可使价值总和最大。

对于没一件物品有两种可能就是放与不放，`dp[i][j]`表示第i件物品放入容量为j的背包所得的最大价值，即为`dp[i][j]=max{dp[i-1][j-v[i]]+c[i],dp[i-1][j]}`;这里从`j=V`倒推回来的话可以优化成 `dp[j]=max{dp[j],dp[j-v[i]]+c[i]}`;

核心代码：

```
for（i=1;i<=n;i++）{
   for(j=V;j>=0;j--){
        if(j>=v[i])
          dp[j]=max{dp[j],dp[j-v[i]]+c[i]};
   }
}
```
`dp[v]`即为最大的价值。

#### 7.完全背包问题

有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是`v[i]`，价值是`ｃ[i]`。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

对于每件物品就不是放与不放的问题了，而是放0件1件.......

可以像01背包一样
`dp[i][j]`表示容量为ｊ的背包第i件物品是否要再一次放入所以我们要从`0-Ｖ`顺序循环

`dp[i][j]=max{dp[i-1][j-v[i]]+c[i],dp[i-1][j]}`(注意这里和01背包一样但是求解的过程不同）

优化后：`dp[j]=max{dp[j],dp[j-v[i]]+c[i]};`

核心代码：

```C++
for（i=1;i<=n;i++）{
    for(j=v[i];j<=v;j++){//注意这里是从v[i]开始到Ｖ
       if(j>=v[i])
          dp[j]=max{dp[j],dp[j-v[i]]+c[i]};
    }
}

```
注意这列求出的`dp[v]`是最大的因为一直叠加。

#### 8.多重背包问题

有N种物品和一个容量为V的背包。第i种物品最多有`n[i]`件可用，每件费用是`c[i]`，价值是`w[i]`。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

因为对于第i种物品有`n[i]+1`种策略：取0件，取1件……取n[i]件。

重点：令`dp[i][j]`表示前i种物品恰放入一个容量为j的背包的最大价值。

状态转移方程：`dp[i][j]=max{dp[i-1][v-k*v[i]]+k*c[i]|0<=k<=n[i]}`;(k表示第i种物品放入ｋ件);

核心代码：

```C++
for(i=1;i<=n;i++){
    for(j=v;j>=0;j--){
         for(k=1;k<=n[i];k++){
             if(j>=k*v[i])
                dp[i][j]=max(dp[i-1][v-k*v[i]]+k*c[i])
         }
}
```

#### 9.二维费用的背包问题

二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。

设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为`a[i]`和`b[i]`。

两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为`w[i]`；
费用加了一维，只需状态也加一维即可。设`f[i][v][u]`表示前i件物品付出两种代价分别为v和u时可获得的最大价值。

状态转移方程:`f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}`

#### 10.最大子段和问题(最大子序列的和不同）

给定一个序列为`a1,a2,a3......an`;

要求：求出这个序列里面找到一个子段和最大

`dp[i]`表示以第i个元素结束，求出所有的“以第i个元素结束的连续数组最大和`dp[i]`

就有：

* 如果dp[i-1]>0,无论ai为何值，有dp[i]=dp[i-1]+ai;
* 如果dp[i-1]<=0;舍弃，重新令dp[i]=ai;(因为dp[i-1]为负数无论ai为什么值加上去都会减少)
* 状态转移方程：`dp[i]=dp[i-1]+ai (dp[i-1]>0)
                       dp[i]=ai(dp[i-1]<=0)`

#### 11.最大m子段和

在限制条件增加一维时,可以将状态也相应的增加一维,来进行状态转移。

以`dp[i][j]`表示以第i个元素为结尾,使用j个子段所能达到的最大值(这一维的状态,正是对应了新的限制条件)

状态转移方程:
```C++
dp[i][j]= max{ dp[i - 1][j] + a[i], dp[i - k][j - 1] + a[i]}( j - 1 <= k <n - m + j).
1.dp[i - 1][j] + a[i] (把第i个元素包含在最后一个子段内)
2.dp[i - k][j - 1] + a[i], j - 1 <= k < n - m + j(第i个元素单独为一子串)
```
#### 12.区间DP

区间动态规划问题一般都是考虑，对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合，求合并后的最优值。

- 设`F[i,j]`（1<=i<=j<=n）表示区间[i,j]内的数字相加的最小代价。
- 最小区间`F[i,i]=0`（一个数字无法合并，∴代价为0）。
- 每次用变量k（i<=k<=j-1）将区间分为`[i,k]`和`[k+1,j]`两段。
- 区间DP模板，代码
```C++
 for(int p = 1 ; p <= n ; p++){//p是区间的长度，作为阶段
       for(int i = 1 ; i <= n-p ; i++){//i是穷举区间的起点
           int j = i+p;//j为区间的终点
           for(int k = i+1 ; k < j ; k++)//状态转移
               dp[i][j] = min{dp[i][k]+dp[k+1][j]+w[i][j]};//这个是看具体的状态转移方程
              或 dp[i][j] = max{dp[i][k]+dp[k+1][j]+w[i][j]};//求最大
              或  dp[i][j] = min{dp[i][k]+dp[k][j]+w[i][j]}//有的是要从k开始不是k+1
          }
}
```














:wq
